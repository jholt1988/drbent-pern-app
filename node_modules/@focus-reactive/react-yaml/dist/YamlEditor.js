"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _slicedToArray2 = _interopRequireDefault(require("@babel/runtime/helpers/slicedToArray"));

var _react = _interopRequireDefault(require("react"));

var _jsYaml = _interopRequireDefault(require("js-yaml"));

var _YamlInput = _interopRequireDefault(require("./YamlInput"));

var __jsx = _react["default"].createElement;

var useErrors = function useErrors(onError) {
  var _React$useState = _react["default"].useState(null),
      _React$useState2 = (0, _slicedToArray2["default"])(_React$useState, 2),
      error = _React$useState2[0],
      setError = _React$useState2[1];

  var cleanErrors = function cleanErrors() {
    return setError(null);
  };

  var markError = function markError(_ref) {
    var position = _ref.position,
        message = _ref.message,
        snippet = _ref.snippet;
    setError({
      position: position,
      message: message,
      snippet: snippet
    });
    onError(true);
  };

  return {
    cleanErrors: cleanErrors,
    errorRanges: error,
    markError: markError,
    hasErrors: !!error,
    error: error
  };
};

var defaultMerge = function defaultMerge(_ref2) {
  var text = _ref2.text,
      currentText = _ref2.currentText;

  if (!currentText) {
    return {
      text: text
    };
  }

  return {
    text: currentText
  };
};

var getMergedValue = function getMergedValue(_ref3) {
  var merge = _ref3.merge,
      json = _ref3.json,
      text = _ref3.text,
      currentText = _ref3.currentText;

  if (!text && !currentText && !json) {
    return '';
  }

  if (!text && !json) {
    return currentText;
  }

  var shouldUpdate = merge({
    json: json,
    text: text,
    currentText: currentText
  });

  if (shouldUpdate.text !== undefined && typeof shouldUpdate.text === 'string') {
    return shouldUpdate.text;
  }

  if (shouldUpdate.json) {
    return _jsYaml["default"].dump(shouldUpdate.json);
  }

  throw new Error('merge function should return object with "text" or "json" fields');
};

var YamlEditor = function YamlEditor(_ref4, ref) {
  var json = _ref4.json,
      text = _ref4.text,
      theme = _ref4.theme,
      _ref4$onError = _ref4.onError,
      onError = _ref4$onError === void 0 ? function () {} : _ref4$onError,
      _ref4$onChange = _ref4.onChange,
      onChange = _ref4$onChange === void 0 ? function () {} : _ref4$onChange,
      _ref4$onSelect = _ref4.onSelect,
      onSelect = _ref4$onSelect === void 0 ? function () {} : _ref4$onSelect,
      _ref4$onSetCursor = _ref4.onSetCursor,
      onSetCursor = _ref4$onSetCursor === void 0 ? function () {} : _ref4$onSetCursor,
      _ref4$merge = _ref4.merge,
      merge = _ref4$merge === void 0 ? defaultMerge : _ref4$merge;

  var actionsRef = _react["default"].useRef(null);

  var errors = useErrors(onError);
  var textValue = json ? _jsYaml["default"].dump(json) : text;

  var currentText = _react["default"].useRef(textValue);

  var replaceValue = function replaceValue(val) {
    if (!val.json && !val.text) {
      return;
    }

    var newText = val.json ? _jsYaml["default"].dump(val.json) : val.text;
    actionsRef.current.actionNewDoc({
      text: newText
    });
  };

  var mergedValue = _react["default"].useMemo(function () {
    return getMergedValue({
      merge: merge,
      json: json,
      text: text,
      currentText: currentText.current
    });
  }, [json, text, merge]);

  _react["default"].useEffect(function () {
    if (mergedValue !== currentText.current) {
      replaceValue({
        text: mergedValue
      });
    }
  }, [mergedValue]);

  var handleChange = function handleChange(newText) {
    try {
      currentText.current = newText;

      var newJson = _jsYaml["default"].load(newText);

      if (errors.hasErrors) {
        errors.cleanErrors();
        onError(null);
      }

      onChange({
        json: newJson,
        text: newText
      });
    } catch (err) {
      var _err$mark;

      onError(err);

      if (!((_err$mark = err.mark) !== null && _err$mark !== void 0 && _err$mark.snippet)) {
        console.error(err);
        return;
      }

      console.error(err.mark.snippet);
      errors.markError({
        position: err.mark.position,
        message: err.message,
        snippet: err.mark.snippet
      });
    }
  };

  var actions = {
    replaceValue: replaceValue
  };

  if (ref) {
    // eslint-disable-next-line no-param-reassign
    ref.current = actions;
  }

  var handleSelect = function handleSelect(selected) {
    onSelect(selected);
  };

  var handleSetCursor = function handleSetCursor(underCursor) {
    onSetCursor(underCursor);
  };

  var getErrorPos = function getErrorPos(newText) {
    try {
      _jsYaml["default"].load(newText);

      return {};
    } catch (err) {
      var _err$mark2;

      if (!((_err$mark2 = err.mark) !== null && _err$mark2 !== void 0 && _err$mark2.snippet)) {
        return {};
      }

      return {
        position: err.mark.position
      };
    }
  };

  return __jsx(_YamlInput["default"], {
    value: mergedValue,
    onChange: handleChange,
    onSelect: handleSelect,
    onSetCursor: handleSetCursor,
    error: errors.error,
    getErrorPos: getErrorPos,
    options: {
      handleTabs: true,
      theme: theme
    },
    ref: actionsRef
  });
};

var _default = /*#__PURE__*/_react["default"].forwardRef(YamlEditor);

exports["default"] = _default;