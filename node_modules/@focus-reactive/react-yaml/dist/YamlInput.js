"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _react = _interopRequireDefault(require("react"));

var _streamParser = require("@codemirror/stream-parser");

var _yaml = require("@codemirror/legacy-modes/mode/yaml");

var _basicSetup = require("@codemirror/basic-setup");

var _view = require("@codemirror/view");

var _commands = require("@codemirror/commands");

var _state = require("@codemirror/state");

var _tooltip = require("@codemirror/tooltip");

var _zebraStripes = require("./extensions/zebra-stripes");

var _errorStripe = require("./extensions/error-stripe");

var _model = require("./model");

var __jsx = _react["default"].createElement;

function _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it["return"] != null) it["return"](); } finally { if (didErr) throw err; } } }; }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

// Effects can be attached to transactions to communicate with the extension
var addMarks = _state.StateEffect.define();

var filterMarks = _state.StateEffect.define();

var myTheme = _basicSetup.EditorView.theme({
  '.cm-activeLine': {
    backgroundColor: '#5973bb2e'
  }
}); // This value must be added to the set of extensions to enable this


var markFieldExtension = _state.StateField.define({
  // Start with an empty set of decorations
  create: function create() {
    return _view.Decoration.none;
  },
  // This is called whenever the editor updatesâ€”it computes the new set
  update: function update(prevValue, tr) {
    // Move the decorations to account for document changes
    var newValue = prevValue.map(tr.changes); // If this transaction adds or removes decorations, apply those changes
    // eslint-disable-next-line no-restricted-syntax

    var _iterator = _createForOfIteratorHelper(tr.effects),
        _step;

    try {
      for (_iterator.s(); !(_step = _iterator.n()).done;) {
        var effect = _step.value;

        if (effect.is(addMarks)) {
          newValue = newValue.update({
            add: effect.value,
            sort: true
          });
        }

        if (effect.is(filterMarks)) {
          newValue = newValue.update({
            filter: effect.value
          });
        }
      }
    } catch (err) {
      _iterator.e(err);
    } finally {
      _iterator.f();
    }

    return newValue;
  },
  // Indicate that this field provides a set of decorations
  provide: function provide(f) {
    return _basicSetup.EditorView.decorations.from(f);
  }
});

var errorMark = _view.Decoration.mark({
  attributes: {
    style: 'background-color: rgba(255, 0, 0, 0.5)'
  }
});

var YamlInput = /*#__PURE__*/_react["default"].forwardRef(function (_ref, editorRef) {
  var _ref$value = _ref.value,
      value = _ref$value === void 0 ? '' : _ref$value,
      _ref$onChange = _ref.onChange,
      onChange = _ref$onChange === void 0 ? function () {
    return null;
  } : _ref$onChange,
      _ref$onSelect = _ref.onSelect,
      onSelect = _ref$onSelect === void 0 ? function () {
    return null;
  } : _ref$onSelect,
      _ref$onSetCursor = _ref.onSetCursor,
      onSetCursor = _ref$onSetCursor === void 0 ? function () {
    return null;
  } : _ref$onSetCursor,
      error = _ref.error,
      _ref$options = _ref.options;
  _ref$options = _ref$options === void 0 ? {} : _ref$options;
  var _ref$options$theme = _ref$options.theme,
      theme = _ref$options$theme === void 0 ? undefined : _ref$options$theme,
      _ref$options$handleTa = _ref$options.handleTabs,
      handleTabs = _ref$options$handleTa === void 0 ? false : _ref$options$handleTa,
      getErrorPos = _ref.getErrorPos;

  var mount = _react["default"].useRef(null);

  var view = _react["default"].useRef(null);

  var currentValue = _react["default"].useRef(value);

  var currentSelection = _react["default"].useRef('');

  var currentUnderCursorWord = _react["default"].useRef('');

  var actionReplace = function actionReplace(_ref2) {
    var text = _ref2.text,
        from = _ref2.from,
        to = _ref2.to;
    var toCalc = to || from + text.length;
    view.current.dispatch({
      changes: {
        from: from,
        to: toCalc,
        insert: text
      }
    });
  };

  var actionNewDoc = function actionNewDoc(_ref3) {
    var text = _ref3.text;
    var currentText = view.current.state.doc.toString();
    var currentPos = view.current.state.selection.ranges[0].from;
    var to = currentText.length;
    view.current.dispatch({
      changes: {
        from: 0,
        to: to,
        insert: text
      },
      selection: _state.EditorSelection.cursor(currentPos)
    });
  }; // eslint-disable-next-line no-param-reassign


  editorRef.current = {
    actionReplace: actionReplace,
    actionNewDoc: actionNewDoc
  };

  var handleErrors = function handleErrors() {
    view.current.dispatch({
      effects: filterMarks.of(function () {
        return false;
      })
    });

    if (!(error !== null && error !== void 0 && error.position)) {
      return;
    }

    var textLength = view.current.state.doc.length;
    var fromPosition = (error === null || error === void 0 ? void 0 : error.position) + 1 <= textLength - 1 ? error.position : textLength - 1;
    var toPosition = fromPosition + 1;
    view.current.dispatch({
      effects: addMarks.of([errorMark.range(fromPosition, toPosition)])
    });
  };

  var handleChange = function handleChange(viewUpdate) {
    var _viewUpdate$state, _viewUpdate$state$sel;

    var newValue = viewUpdate.state.doc.toString();
    var selection = ((_viewUpdate$state = viewUpdate.state) === null || _viewUpdate$state === void 0 ? void 0 : (_viewUpdate$state$sel = _viewUpdate$state.selection) === null || _viewUpdate$state$sel === void 0 ? void 0 : _viewUpdate$state$sel.ranges[0]) || {};
    var from = selection.from,
        to = selection.to;
    var selected = newValue.slice(from, to);
    var underCursor = from === to ? (0, _model.getCurrentWord)(newValue, from) : {};

    if (selected !== currentSelection.current) {
      currentSelection.current = selected;
      onSelect({
        selected: selected,
        from: from,
        to: to
      });
    }

    if (underCursor.word !== currentUnderCursorWord.current) {
      currentUnderCursorWord.current = underCursor.word;
      onSetCursor(underCursor);
    }

    if (newValue !== currentValue.current) {
      currentValue.current = newValue;
      handleErrors();
      onChange(newValue);
    }
  };

  var errorHover = (0, _tooltip.hoverTooltip)(function (view, pos, side) {
    var _view$state$field;

    // const { from, to, text } = view.state.doc.lineAt(pos);
    var hasErrors = (_view$state$field = view.state.field(markFieldExtension)) === null || _view$state$field === void 0 ? void 0 : _view$state$field.size;

    if (!hasErrors) {
      return null;
    }

    return {
      pos: pos,
      above: true,
      create: function create(view) {
        var dom = document.createElement('div');
        dom.style = 'width: 100px; height: 100px';
        dom.textContent = 'error';
        return {
          dom: dom
        };
      }
    };
  });

  var initEditor = function initEditor() {
    var extensions = [myTheme, _basicSetup.basicSetup, _streamParser.StreamLanguage.define(_yaml.yaml), _basicSetup.EditorView.updateListener.of(handleChange), handleTabs && _view.keymap.of([_commands.indentWithTab]), markFieldExtension, errorHover, (0, _errorStripe.errorStripe)(getErrorPos), (0, _zebraStripes.zebraStripes)(), theme].filter(Boolean);

    var state = _basicSetup.EditorState.create({
      doc: value,
      extensions: extensions
    });

    view.current = new _basicSetup.EditorView({
      state: state,
      parent: mount === null || mount === void 0 ? void 0 : mount.current
    });
    window.view = view.current;
    window.actionReplace = actionReplace;
  };

  _react["default"].useEffect(function () {
    if (!mount.current) {
      throw new Error("Can't find a mounting point for YamlEditor");
    }

    initEditor();
    return function () {
      view.current.destroy();
    }; // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [theme]);

  _react["default"].useEffect(handleErrors);

  return __jsx("div", {
    ref: mount
  });
});

var _default = YamlInput;
exports["default"] = _default;